#!/bin/bash
# Swarms
# deploy this application onto a cluster, running it on multiple machines. Multi-container, multi-machine applications are made possible by joining multiple machines into a “Dockerized” cluster called a swarm.
# A swarm is a group of machines that are running Docker and joined into a cluster.
 # but now they are executed on a cluster by a swarm manager. The machines in a swarm can be physical or virtual. After joining a swarm, they are referred to as nodes.
 # Swarm managers are the only machines in a swarm that can execute your commands, or authorize other machines to join the swarm as workers.

# But Docker also can be switched into swarm mode, and that’s what enables the use of swarms.
# Set up your swarm
# A swarm is made up of multiple nodes, which can be either physical or virtual machines.
# run docker swarm init to enable swarm mode and make your current machine a swarm manager, then run docker swarm join on other machines to have them join the swarm as workers.
# We’ll use VMs to quickly create a two-machine cluster and turn it into a swarm.
# First, you’ll need a hypervisor that can create virtual machines (VMs), so install Oracle VirtualBox for your machine’s OS.
# https://docs.docker.com/machine/install-machine/
# https://github.com/docker/machine/
curl -L https://github.com/docker/machine/releases/download/v0.13.0/docker-machine-`uname -s`-`uname -m` >/tmp/docker-machine &&
chmod +x /tmp/docker-machine &&
sudo cp /tmp/docker-machine /usr/local/bin/docker-machine
# Now, create a couple of VMs using docker-machine, using the VirtualBox driver:
docker-machine create --driver virtualbox myvm1
docker-machine create --driver virtualbox myvm2
docker-machine ls
# NAME    ACTIVE   DRIVER       STATE     URL                         SWARM   DOCKER        ERRORS
# myvm1   -        virtualbox   Running   tcp://192.168.99.100:2376           v17.11.0-ce
# myvm2   -        virtualbox   Running   tcp://192.168.99.101:2376           v17.11.0-ce
# You can send commands to your VMs using docker-machine ssh. Instruct myvm1 to become a swarm manager with docker swarm init and you’ll see output like this:
docker-machine ssh myvm1 "docker swarm init --advertise-addr 192.168.99.100"
# docker swarm join --token SWMTKN-1-3w1lp3alwjbq8t9u2jvhpel0imr596w2g4uxh8sdt6o15bkpe5-7kk0cfk7e6f6jwq8j5lbyf6g2 192.168.99.100:2377
# Ports 2377 and 2376
# Always run docker swarm init and docker swarm join with port 2377 (the swarm management port), or no port at all and let it take the default.
docker-machine ssh myvm2 "docker swarm join \
--token SWMTKN-1-4a686iv64d1flti29kzdzxie877y4zy1xg41zxj73oim0jdouf-2bsmz4wiaqu6tor7xsvurlzb4 \
192.168.99.100:2377"
docker-machine ssh myvm1 "docker node ls"
# ID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS
# rvd0oj3q5bcaedamad0pxvmuj *   myvm1               Ready               Active              Leader
# va34x42bvxcyntkofbxx2ffhf     myvm2               Ready               Active
# Leaving a swarm
# If you want to start over, you can run docker swarm leave from each node.
# Deploy your app on the swarm cluster
# The hard part is over. Now you just repeat the process you used in part 3 to deploy on your new swarm. Just remember that only swarm managers like myvm1 execute Docker commands; workers are just for capacity.
# you’ve been wrapping Docker commmands in docker-machine ssh to talk to the VMs. Another option is to run docker-machine env <machine> to get and run a command that configures your current shell to talk to the Docker daemon on the VM. This method works better for the next step because it allows you to use your local docker-compose.yml file to deploy the app “remotely” without having to copy it anywhere.
docker-machine env myvm1
# xport DOCKER_TLS_VERIFY="1"
# export DOCKER_HOST="tcp://192.168.99.100:2376"
# export DOCKER_CERT_PATH="/home/yaozai/.docker/machine/machines/myvm1"
# export DOCKER_MACHINE_NAME="myvm1"
# # Run this command to configure your shell:
# # eval $(docker-machine env myvm1)
# Run the given command to configure your shell to talk to myvm1.
eval $(docker-machine env myvm1)
docker-machine ls
# Just like before, run the following command to deploy the app on myvm1.
docker stack deploy -c docker-compose.yml getstartedlab
docker stack ps getstartedlab
# Connecting to VMs with docker-machine env and docker-machine ssh
# To set your shell to talk to a different machine like myvm2, simply re-run docker-machine env in the same or a different shell, then run the given command to point to myvm2. This is always specific to the current shell. If you change to an unconfigured shell or open a new one, you need to re-run the commands. Use docker-machine ls to list machines, see what state they are in, get IP addresses
# Alternatively, you can wrap Docker commands in the form of docker-machine ssh <machine> "<command>", which logs directly into the VM but doesn’t give you immediate access to files on your local host.
# On Mac and Linux, you can use docker-machine scp <file> <machine>:~ to copy files across machines, but Windows users need a Linux terminal emulator like Git Bash in order for this to work.
curl -4 192.168.99.100:4000
curl -4 192.168.99.101:4000
# Iterating and scaling your app
# From here you can do everything you learned about in parts 2 and 3.
# Scale the app by changing the docker-compose.yml file.
# Change the app behavior by editing code, then rebuild, and push the new image. (To do this, follow the same steps you took earlier to build the app and publish the image).
# Unsetting docker-machine shell variable settings
# You can unset the docker-machine environment variables in your current shell with the following command:

eval $(docker-machine env -u)

# This disconnects the shell from docker-machine created virtual machines, and allows you to continue working in the same shell, now using native docker commands (for example, on Docker for Mac or Docker for Windows). To learn more, see the Machine topic on unsetting environment variables.
# docker-machine create --driver virtualbox myvm1 # Create a VM (Mac, Win7, Linux)
# docker-machine create -d hyperv --hyperv-virtual-switch "myswitch" myvm1 # Win10
# docker-machine env myvm1                # View basic information about your node
# docker-machine ssh myvm1 "docker node ls"         # List the nodes in your swarm
# docker-machine ssh myvm1 "docker node inspect <node ID>"        # Inspect a node
# docker-machine ssh myvm1 "docker swarm join-token -q worker"   # View join token
# docker-machine ssh myvm1   # Open an SSH session with the VM; type "exit" to end
# docker node ls                # View nodes in swarm (while logged on to manager)
# docker-machine ssh myvm2 "docker swarm leave"  # Make the worker leave the swarm
# docker-machine ssh myvm1 "docker swarm leave -f" # Make master leave, kill swarm
# docker-machine ls # list VMs, asterisk shows which VM this shell is talking to
# docker-machine start myvm1            # Start a VM that is currently not running
# docker-machine env myvm1      # show environment variables and command for myvm1
# eval $(docker-machine env myvm1)         # Mac command to connect shell to myvm1
# & "C:\Program Files\Docker\Docker\Resources\bin\docker-machine.exe" env myvm1 | Invoke-Expression   # Windows command to connect shell to myvm1
# docker stack deploy -c <file> <app>  # Deploy an app; command shell must be set to talk to manager (myvm1), uses local Compose file
# docker-machine scp docker-compose.yml myvm1:~ # Copy file to node's home dir (only required if you use ssh to connect to manager and deploy the app)
# docker-machine ssh myvm1 "docker stack deploy -c <file> <app>"   # Deploy an app using ssh (you must have first copied the Compose file to myvm1)
# eval $(docker-machine env -u)     # Disconnect shell from VMs, use native docker
# docker-machine stop $(docker-machine ls -q)               # Stop all running VMs
# docker-machine rm $(docker-machine ls -q) # Delete all VMs and their disk images

docker-machine stop $(docker-machine ls -q)
docker-machine rm $(docker-machine ls -q)
